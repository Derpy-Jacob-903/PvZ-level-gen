<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title></title>
</head>

<body>
    <div> Please choose an alias: </div>
    <select id="reee" onchange="">
        <option>Endangered</option>
        <option>ModifyPlantCooldown</option>
        <option>SunBombs</option>
        <option>FasterZombies</option>
        <option>LootOverride</option>
        <option>Pirate Seas' plank</option>
        <option>Rails/Railcarts</option>
        <option>ItemSpawn</option>
        <option>InitialPlantPlacements</option>
        <option>InitialZombiePlacements</option>
        <option disabled>Challenges:</option>
        <option>SunProduced</option>
        <option>SimutaneousPlants</option>
        <option>PlantsLost</option>
        <option>MoldColonies</option>
        <option>WaveCreator</option>
    </select>
    <button type="button" onclick="onAliasSelect();">Select!</button>
    <form>
        <fieldset id='myGroupBox'>
        </fieldset>

    </form>

    <script>
        // ui elements
        var myGroupBox;

        //data variables
        var userInput = {};
        var myGrid;
        var rails = [];
        var railCarts = [];
        var itemsObj = {};
        var spawnObj = [];
        var iPCount;
        var maxPCount;
        var spawnTimer = {};
        var a;//field
        var moldConfig = [];
        var c; //param o' box
        var zArr = [];

        //this one get a global flag for nest()
        var fireNest;
        var nestArr1 = [];
        var nestArr2 = [];
        var spawnGridNestArr = [];
        var zGridNestArr = [];
        var frostWindArr = [];
        var addFlagWave = []

        //functions
        var completeObjdata;

        //global scope to define when should createObj() run:
        var runCreateObj = {};

        // file object
        var challengeModules = {}, fileObj = {}, challengeModulesDefinition = [];
        var waveSmallArr = [], waveBigArr = [];
        //create sub box
        var subBox = document.createElement('fieldset');
        subBox.id = "mySubGroupBox";
        document.body.appendChild(subBox);
        hideSubBox();
        function onAliasSelect() {
            myGroupBox = document.getElementById("myGroupBox");
            chosen = document.getElementById("reee").selectedIndex;
            hideSubBox();

            switch (chosen) {
                case 0:
                    handleEndangered();
                    break;
                case 1:
                    handleModifyPlantCooldown();
                    break;
                case 2:
                    handleSunBombs();
                    break;
                case 3:
                    handleSpeedyZombie();
                    break;
                case 4:
                    handleLootOverride();
                    break;
                case 5:
                    handlePlank();
                    break;
                case 6:
                    handleRails();
                    break;
                case 7:
                    handlePotion();
                    break;
                case 8:
                    handleIntPlants();
                    break;
                case 9:
                    handleIntZombies();
                    break;
                case 10:
                    handleGridItems();
                    break;
                //break case 11 cuz not selectable
                case 11:
                    handleSunProduced();
                    break;
                case 12:
                    handleMaxPlants();
                    break;
                case 13:
                    handleMaxPlantsLost();
                    break;
                case 14:
                    handleMold(); //WHY THE FUCK AM I HERE ALREADY
                    break;
                case 15:
                    handleWave();
                default:
                //hacker detected!!
            };
        }


        function handleEndangered() {
            myGrid = {
                "className": "Endangered",
                "data": [
                    { "name": "GridX", "id": "gridxID", "displayTxt": "Provide GridX: ", "type": "number", "min": "0", "max": "9" },
                    { "name": "GridY", "id": "gridyID", "displayTxt": "Provide GridY: ", "type": "number", "min": "0", "max": "9" },
                    { "name": "PlantType", "id": "plantType", "displayTxt": "Provide a plant's name (internal): ", "type": "text" }
                ]
            };
            runCreateObj.toSubmit = true;
            createUI();

            //all var to create ed plants
            var ePlants = [], endangeredObj = {}, eAlias = ["ProtectThePlant"], ePlantsData = {};
            completeObjdata = function () {
                runCreateObj.run = true;
                ePlants.push(userInput)
                function createObj() {
                    endangeredObj.aliases = eAlias;
                    endangeredObj.objclass = "ProtectThePlantChallengeProperties";
                    ePlantsData.MustProtectCount = ePlants.length;
                    ePlantsData.Plants = ePlants;
                    endangeredObj.objdata = ePlantsData;
                    console.log(JSON.stringify(endangeredObj))
                }
                completeObjdata.createObj = createObj;
            }
        }

        function handleModifyPlantCooldown() {
            myGrid = {
                "className": "ModifyPlantCooldown",
                "data": [
                    { "name": "CooldownMultiplier", "id": "cooldownMod", "displayTxt": "Define CooldownMultiplier", "type": "number", "min": "", "max": "" },
                    { "name": "HomeworldToExcludeFromOverride", "id": "cooldownExclusion", "displayTxt": "Exclude a homeworld from CooldownMod", "type": "text" }
                ]
            };
            createUI();
            completeObjdata = function () {
                runCreateObj.run = false;
                var cModObj = {}, cModAlias = ["CooldownMod"];
                cModObj.aliases = cModAlias;
                cModObj.objclass = "PlantCooldownModifierProperties";
                cModObj.objdata = userInput;
                console.log(JSON.stringify(cModObj));
            }
        }

        function handleSunBombs() {
            myGrid = {
                "className": "SunBombs",
                "data": [
                    { "name": "PlantBombExplosionRadius", "id": "pBombRadius", "displayTxt": "Range SunBombs will apply to plants: ", "type": "number", "min": "0", "max": "" },
                    { "name": "ZombieBombExplosionRadius", "id": "zBombRadius", "displayTxt": "Range SunBombs will apply to zombies: ", "type": "number", "min": "0", "max": "" },
                    { "name": "PlantDamage", "id": "sBombpDamage", "displayTxt": "How hurtful will the bomb be to plants? ", "type": "number", "min": "0", "max": "" },
                    { "name": "ZombieDamage", "id": "sBombzDamage", "displayTxt": "How hurtful will the bomb be to zombies? ", "type": "number", "min": "0", "max": "" }
                ]
            };
            createUI();
            completeObjdata = function () {
                runCreateObj.run = false;
                var sBombsObj = {}, sBombsAlias = ["SunBombChallengeProperties"];
                sBombsObj.aliases = sBombsAlias;
                sBombsObj.objclass = "SunBombChallengeProperties";
                sBombsObj.objdata = userInput;
                console.log(JSON.stringify(sBombsObj));
            }
        }

        function handleSpeedyZombie() {
            myGrid = {
                "className": "FasterZombies",
                "data": [
                    { "name": "Speedy", "id": "speedChk", "displayTxt": "Will zombies in this level be faster than normal? (checked is true) ", "type": "checkbox" }
                ]
            };
            createUI();
            completeObjdata = function () {
                runCreateObj.run = false;
                var speedyObj = {}, speedyAlias = ["SpeedyZombies"], speedyObjdata = {}
                speedyObj.aliases = speedyAlias;
                speedyObj.objclass = "SpeedyZombies";
                var chkBox = document.getElementById("speedChk");
               /* if (chkBox.checked == true) {
                    speedyObjdata.Speedy = true;
                }
                else {
                    speedyObjdata.Speedy = false;
                } */
                speedyObj.objdata = speedyObjdata;
                console.log(JSON.stringify(speedyObj))
            }
        }

        function handleLootOverride() {
            myGrid = {
                "className": "LootOverride",
                "data": [
                    { "name": "ZombieType", "id": "lootOverrideZType", "displayTxt": "Choose a zombie to override loot drop (internal): ", "type": "text" },
                    { "name": "LootOverride", "id": "lootToOverride", "displayTxt": "Override with which type of loot? ", "type": "text" }
                ]
            }; runCreateObj.toSubmit = true;
            createUI();
            var lootOverrideArray = [], lootOverrideAlias = ["LootOverride"], lootOverrideObj = {}, lootOverrideObjdata = {}, validZType;
            completeObjdata = function () {
                runCreateObj.run = true;

                validZType = "RTID(" + userInput.ZombieType + "@ZombieTypes)";
                var realOverride = {};
                realOverride[myGrid.data[0].name] = validZType;
                realOverride[myGrid.data[1].name] = userInput.LootOverride;
                lootOverrideArray.push(realOverride);
                function createObj() {
                    lootOverrideObj.aliases = lootOverrideAlias;
                    lootOverrideObj.objclass = "LootOverrideModuleProperties";
                    lootOverrideObjdata.Overrides = lootOverrideArray;
                    lootOverrideObj.objdata = lootOverrideObjdata;
                    console.log(JSON.stringify(lootOverrideObj));
                }
                completeObjdata.createObj = createObj;
            }
        }

        function handlePlank() {
            myGrid = {
                "className": "Plank",
                "data": [
                    { "name": "PlankRows", "id": "PSPlank", "displayTxt": "Which row do you want to place plank on? (only work for Pirate Seas) ", "type": "number", "min": "0", "max": "4" }
                ]
            }; runCreateObj.toSubmit = true;
            createUI();
            var plankRows = [], plankObj = {}, plankObjdata = {}, plankAlias = ["PiratePlanks"];
            completeObjdata = function () {
                runCreateObj.run = true;
                plankRows.push(userInput);
                function createObj() {
                    plankObj.aliases = plankAlias;
                    plankObj.objclass = "PiratePlankProperties";
                    plankObjdata.PlankRows = plankRows;
                    plankObj.objdata = plankObjdata;
                    console.log(JSON.stringify(plankObj));
                }
                completeObjdata.createObj = createObj;
            }
        }

        function handleRails() {
            rails = [];
            railCarts = [];
            createRailsUI();

            var railsRows = [], railsObj = {}, railsObjdata = {}, railsAlias = ["CowboyRails"];
            completeObjdata = function () {
                function createObj() {
                    railsObj.aliases = railsAlias;
                    railsObj.objclass = "RailCartProperties";
                    railsObj.objdata = userInput;
                    console.log(JSON.stringify(railsObj));
                };
                completeObjdata.createObj = createObj;
            }
        }

        function createRailsUI() {
            clearInputArea();
            addText("Railcart type: ");
            myGroupBox.appendChild(createInput('text', 'railCartTypeID', 'myClass', 'railcart_cowboy'));
            newLine(); newLine();

            //add rails first
            addText("Add rails: "); newLine();
            addText("Column: "); createInput('number', 'railColumnID', 'myClass', 1); addText("  ");
            addText("Row Start: "); createInput('number', 'railRowStartID', 'myClass', 1); addText("  ");
            addText("Row End: "); createInput('number', 'railRowEndID', 'myClass', 3); addText("  ");

            var clickHandler = function () {
                var myRail = {};
                rails.push(myRail);
                myRail['Column'] = readIntInput("railColumnID");
                myRail['RowStart'] = readIntInput("railRowStartID");
                myRail['RowEnd'] = readIntInput("railRowEndID");
                console.log('Added rail: ' + JSON.stringify(myRail));
            };
            myGroupBox.appendChild(createButton('Add', clickHandler));

            clickHandler = function () {
                rails = [];
            };
            myGroupBox.appendChild(createButton('Clear all rails', clickHandler));
            newLine(); newLine();

            //add carts
            addText("Add Rail Carts: "); newLine();
            addText("Column: "); createInput('number', 'railCartColumnID', 'myClass', 1); addText("  ");
            addText("Row: "); createInput('number', 'railCartRowID', 'myClass', 1); addText("  ");

            clickHandler = function () {
                var myRailCart = {};
                railCarts.push(myRailCart);
                myRailCart['Column'] = readIntInput("railCartColumnID");
                myRailCart['Row'] = readIntInput("railCartRowID");
                console.log('Added rail cart: ' + JSON.stringify(myRailCart));
            };
            myGroupBox.appendChild(createButton('Add', clickHandler));

            clickHandler = function () {
                railCarts = [];
            };
            myGroupBox.appendChild(createButton('Clear all carts', clickHandler));
            newLine(); newLine();


            //submit buttons
            clickHandler = function () {
                userInput = readRailsData();
                completeObjdata();
                //instead of setting all input to blank, just create new ui.
                createRailsUI();
            };
            //myGroupBox.appendChild(createButton('Submit', clickHandler));


            clickHandler = function () {
                userInput = readRailsData();
                completeObjdata();
                completeObjdata.createObj();
            };
            myGroupBox.appendChild(createButton('Submit and generate chosen object', clickHandler));
        }
        //okay item spawn, this is a f*cking mess
        function handlePotion() {
            addPotionUI();
            var itemsAlias = ['GridItemSpawn'];
            completeObjdata = function () {
                function createObj() {
                    itemsObj.aliases = itemsAlias;
                    itemsObj.objclass = "ZombiePotionModuleProperties";
                    itemsObj.objdata = userInput;
                    console.log(JSON.stringify(itemsObj));
                };
                completeObjdata.createObj = createObj;
            }
        }


        function addPotionUI() {
            clearInputArea();
            addText('How many items do you want to leave at start? ');
            myGroupBox.appendChild(createInput('number', 'itemPrePlaceNumber', 'potionClass', ''));
            newLine();
            addText('Maximum amount of items on the lawn?  ');
            myGroupBox.appendChild(createInput('number', 'itemMaxNumber', 'potionClass', ''));
            // handle 2 first obj
            newLine();
            var clickHandler = function () {
                iPCount = readIntInput('itemPrePlaceNumber');
                maxPCount = readIntInput('itemMaxNumber');
                clickHandler.onclick = function () { document.getElementById('toBeDisabled').disabled = true; }
            };
            myGroupBox.appendChild(createButton('Confirm', clickHandler, 'toBeDisabled'));
            newLine(); newLine();
            //create potion timer
            addText('Configure potions:'); newLine();
            addText('Maximum time to spawn item:  '); myGroupBox.appendChild(createInput('number', 'itemMaxSpawnTime', 'potionClass', '')); addText(" ");
            addText('Minimum time to spawn item: '); myGroupBox.appendChild(createInput('number', 'itemMinSpawnTime', 'potionClass', '')); addText(" ");
            //handle time
            clickHandler = function () {
                spawnTimer.Max = readIntInput('itemMaxSpawnTime');
                spawnTimer.Min = readIntInput('itemMinSpawnTime');
                clickHandler.onclick = function () { document.getElementById('toBeDisabled2').disabled = true; };
            }
            myGroupBox.appendChild(createButton('Confirm', clickHandler, 'toBeDisabled2'));
            newLine(); newLine();
            addText('What do you want to spawn? '); myGroupBox.appendChild(createInput('text', 'itemToSpawn', 'itemSpawnId', ''))
            //lol handler
            clickHandler = function () {
                spawnObj.push(readTxtInput('itemToSpawn'))
            };
            myGroupBox.appendChild(createButton('Add', clickHandler));
            clickHandler = function () {
                userInput = function () {
                    itemsObj.InitialPotionCount = iPCount;
                    itemsObj.MaxPotionCount = maxPCount;
                    itemsObj.PotionSpawnTimer = spawnTimer;
                    itemsObj.PotionTypes = spawnObj;
                    //call handle potion
                };
                completeObjdata();
                completeObjdata.createObj();
                clickHandler.onclick = function () { document.getElementById('toBeDisabled3').disabled = true; }
            };
            myGroupBox.appendChild(createButton('Generate chosen object', clickHandler, 'toBeDisabled3'));
        }


        function handleIntPlants() {
            myGrid = {
                "data": [
                    { "name": "IsInitialIntensiveCarrotPlacements", "id": "intPlantsBurn", "displayTxt": "Burn all plants at the start of the level?", "type": "checkbox" },
                    { "name": "Condition", "id": "intConditions", "displayTxt": "Conditions?", "type": "number" },
                    { "name": "GridX", "id": "gridxIDInt", "displayTxt": "Provide GridX: ", "type": "number", "min": "0", "max": "9" },
                    { "name": "GridY", "id": "gridyIDInt", "displayTxt": "Provide GridY: ", "type": "number", "min": "0", "max": "9" },
                    { "name": "Level", "id": "intPlantLvl", "displayTxt": "What level will it be? (-1 for current level)", "type": "number" },
                    { "name": "PlantType", "id": "plantTypeInt", "displayTxt": "Provide a plant's name (internal): ", "type": "text" }
                ]
            }
            runCreateObj.toSubmit = true;
            createUI();
            var intPlants = [], intPObj = {}, intAlias = ["InitialPlants"], intPlantsData = {}, confirmLastOfObj = [];
            completeObjdata = function () {
                runCreateObj.run = true;
                confirmLastOfObj.push(document.getElementById("intPlantsBurn").checked);
                delete userInput.IsInitialIntensiveCarrotPlacements;//just to make sure it doesn't log this one every time the user loops
                intPlants.push(userInput);
                function createObj() {
                    intPObj.aliases = intAlias;
                    intPObj.objclass = "InitialPlantProperties";
                    intPlantsData.IsInitialIntensiveCarrotPlacements = confirmLastOfObj.pop();
                    intPlantsData.InitialPlantPlacements = intPlants;
                    intPObj.objdata = intPlantsData;
                    console.log(JSON.stringify(intPObj));
                }
                completeObjdata.createObj = createObj;
            }
        }

        function handleIntZombies() {
            myGrid = {
                "data": [
                    { "name": "Condition", "id": "intZConditions", "displayTxt": "Conditions? ", "type": "number" },
                    { "name": "GridX", "id": "gridxIDInt", "displayTxt": "Provide GridX: ", "type": "number", "min": "0", "max": "9" },
                    { "name": "GridY", "id": "gridyIDInt", "displayTxt": "Provide GridY: ", "type": "number", "min": "0", "max": "9" },
                    { "name": "TypeName", "id": "plantTypeInt", "displayTxt": "Provide a zombie's name (internal): ", "type": "text" }
                ]
            }
            runCreateObj.toSubmit = true;
            createUI();
            var intZombies = [], intZObj = {}, intZAlias = ["InitialZombies"], intZData = {};
            completeObjdata = function () {
                runCreateObj.run = true;
                intZombies.push(userInput);
                function createObj() {
                    intZObj.aliases = intZAlias;
                    intZObj.objclass = "InitialZombieProperties";
                    intZData.InitialZombiePlacements = intZombies;
                    intZObj.objdata = intZData;
                    console.log(JSON.stringify(intZObj))
                }
                completeObjdata.createObj = createObj;
            }
        }

        function handleGridItems() {
            myGrid = {
                "data": [
                    { "name": "GridX", "id": "gridxIDInt", "displayTxt": "Provide GridX: ", "type": "number", "min": "0", "max": "9" },
                    { "name": "GridY", "id": "gridyIDInt", "displayTxt": "Provide GridY: ", "type": "number", "min": "0", "max": "9" },
                    { "name": "TypeName", "id": "plantTypeInt", "displayTxt": "Provide an item's name (internal): ", "type": "text" }
                ]
            }
            runCreateObj.toSubmit = true;
            createUI();
            var intItems = [], intIObj = {}, intIAlias = ['InitialGridItem'], intIData = {};
            completeObjdata = function () {
                runCreateObj.run = true;
                intItems.push(userInput);
                function createObj() {
                    intIObj.aliases = intIAlias;
                    intIObj.objclass = "InitialGridItemProperties";
                    intIData.InitialGridItemProperties = intItems;
                    intIObj.objdata = intIData;
                }
                completeObjdata.createObj = createObj;
            }
        }

        function handleSunProduced() {
            myGrid = {
                "data": [
                    { "name": "TargetSun", "id": "targetSun", "displayTxt": "Target sun to produce: ", "type": "number", "min": "0", "max": "" }
                ]
            }
            runCreateObj.toSubmit = false;
            createUI();
            var sunPAlias = ['SunProduced'], sunPObj = {};
            completeObjdata = function () {
                runCreateObj.run = false;
                sunPObj.aliases = sunPAlias;
                sunPObj.objclass = "StarChallengeSunProducedProps";
                sunPObj.objdata = userInput;
                console.log(JSON.stringify(sunPObj))
            }
        }

        function handleMaxPlants() {
            myGrid = {
                "data": [
                    { "name": "MaximumPlants", "id": "maxPlantId", 'displayTxt': 'Maximum amount of plants allowed onscreen? ', 'type': 'number', 'min': '0', 'max': '' }
                ]
            }
            runCreateObj.toSubmit = false;
            createUI();
            var maxPlantsAlias = ["SimultaneousPlants"], maxPlantsObj = {};
            completeObjdata = function () {
                runCreateObj.run = false;
                maxPlantsObj.aliases = maxPlantsAlias;
                maxPlantsObj.objclass = "StarChallengeSimultaneousPlantsProps";
                maxPlantsObj.objdata = userInput;
            }
        }

        function handleMaxPlantsLost() {
            myGrid = {
                "data": [
                    { 'name': 'MaximumPlantsLost', 'id': 'maxPlantLostID', 'displayTxt': 'Maximum amount of plants to lose? ', 'type': 'number', 'min': '0', 'max': '' }
                ]
            }
            runCreateObj.toSubmit = false;
            createUI();
            var maxPlantLossAlias = ['PlantsLost'], maxPLossObj = {};
            completeObjdata = function () {
                runCreateObj.run = false;
                maxPLossObj.aliases = maxPlantLossAlias;
                maxPLossObj.objclass = "StarChallengePlantsLostProps";
                maxPLossObj.objdata = userInput;
            }
        }

        function handleMold() {
            var moldTakeObj =
            {
                "aliases": [
                    "MoldColonies"
                ],
                "objclass": "MoldColonyChallengeProps",
                "objdata": {
                    "Locations": "RTID(Mold@CurrentLevel)"
                }
            } //create this so well JSON doesn't mess up
            clearInputArea();
            moldConfig = {
                'data': [
                    { 'display': 'Row 1 ' }, { 'display': 'Row 2 ' }, { 'display': 'Row 3 ' }, { 'display': 'Row 4 ' }, { 'display': 'Row 5 ' }
                ]
            }
            var c = 0;

            var myValidator = function (e) {
                if (e) {
                    var inptBox = e.target;
                    if (inptBox.value.length > inptBox.maxLength) inptBox.value = inptBox.value.slice(0, inptBox.maxLength);
                }
            };
            moldConfig.data.forEach(function createMoldUI(param) {
                var x = document.createTextNode(param.display);
                myGroupBox.appendChild(x);
                var i = 0;
                while (i < 9) {
                    var btn = document.createElement('input');
                    btn.type = 'number';
                    btn.min = 0;
                    btn.max = 1;
                    btn.maxLength = 1;
                    btn.value = '0';
                    btn.id = "moldCollect_" + c + "_" + i;
                    myGroupBox.appendChild(btn);
                    btn.addEventListener('oninput', myValidator, true);
                    btn.addEventListener('input', myValidator, true);
                    addText(" ");
                    i++;
                }
                myGroupBox.appendChild(document.createElement('br'));
                c++;
            }
            )
            var clickHandler = function () {
                moldReadData();
            }
            myGroupBox.appendChild(createButton("Generate object", clickHandler));
        }

        function moldReadData() {
            var c = 0; var r = 0; var moldInptData = []; rows = [];

            for (c = 0; c < moldConfig.data.length; c++) {
                moldInptData[c] = [];
                for (r = 0; r < 9; r++) {
                    var moldCls = document.getElementById("moldCollect_" + c + "_" + r).value;
                    moldInptData[c].push(parseInt(moldCls))
                }
            }

            console.log(moldInptData);
        }

        function handleSeedBank() { //holy crap what did I create..
            var seedBankOption = {}, presetList = [], presetListObj = {}, blacklistArr = [], whitelistArr = [], suggestList = [];
            clearInputArea();
            addText('Preset list: ');
            myGroupBox.appendChild(createInput('text', 'pNames')); addText('   at level  '); myGroupBox.appendChild(createInput('number', 'pLvl'));
            var clickHandler = function () {
                presetListObj.PlantType = readTxtInput('pNames');
                presetListObj.Level = readIntInput('pLvl');
                presetList.push(presetListObj);
                //empty pls. 25/08/2018: What the hell is empty pls?
            }; addText('  ')
            myGroupBox.appendChild(createButton('Add', clickHandler));
            newLine(); newLine();
            addText('Plant blacklist: ');
            myGroupBox.appendChild(createInput('text', 'blackListedP'));
            clickHandler = function () {
                blacklistArr.push(readTxtInput('blacklistedP'));
            };
            addText('  '); myGroupBox.appendChild(createButton('Add', clickHandler));
            newLine(); newLine();
            addText('Plant whilelist: ')
            myGroupBox.appendChild(createInput('text', 'whitelistedP'));
            clickHandler = function () {
                whitelistArr.push(readTxtInput('whitelistedP'));
            }
            addText('  '); myGroupBox.appendChild(createButton('Add', clickHandler));
            newLine(); newLine();
            addText('Suggest plant list: ');
            myGroupBox.appendChild(createInput('text', 'listSuggest'));
            clickHandler = function () {
                var a = readTxtInput('listSuggest');
                if (a.includes(',')) {
                    var b = a.spilt(',')
                    suggestList.push(b);
                }
                else {
                    suggestList.push(a);
                }
            }
            //too lazy to create the obj now to later
        }

        function handleWave() {
            var waveButtons = ['WaveManager', 'WaveManagerProps', 'Escalation', 'WaveModules'];
            var waveEvent = ['Jam', 'LowTide', 'GroundSpawn', '(Sand/Snow)storm', 'RaidingParty', 'GridSpawn', 'SpawnFromGrid', 'BotSwarm', 'TideChange', 'FrostWind', 'ParachuteRain', 'Portal', 'Dino', 'SunDropper'];
            var waveMgr = [];
            var i = 1;
            clearInputArea();
            var handler = function () {
                clearInputArea(true);
                clearSubInputArea(false);
                createEventButton();
                newLine();
                addText("Wave: " + i);
                newLine();
                myGrid = {
                    'data': [
                        { 'name': "AdditionalPlantfood", "type": "number", 'displayTxt': 'Wave plantfood: ', 'min': '0', 'max': '' },
                        { 'name': 'ZombieSpawnPattern', 'type': 'text', 'displayTxt': 'Spawn pattern: ', 'value': 'ZombieSpawnPattern' }
                    ]
                }
                createUI(10);
                askZ(); newLine();
                myGroupBox.appendChild(createButton('Generate wave and events', handleAddWave));
            }
            myGroupBox.appendChild(createButton(waveButtons[0], handler)); addText('      ');

            handleAddWave = function () {
                
            }

            handler = function () { //handler of waveprops
                clearInputArea(true);
                clearSubInputArea(true);
                addText('Please finish creating all your waves before using this! I am not responsibe if there\'s no WaveCount in the code, or your JSON crashes because of this.')
                myGrid = {
                    'data': [ {'name': 'FlagWaveInterval','displayTxt':'Flag interval: ','type':'number','min':'0','id':'flagInterval'},
                    {'name':'SuppressFlagZombie','displayTxt':'Suppress flag zombie? ','type':'checkbox','id':'flagZSupression'},
                    {'name':'LevelJam', 'displayTxt':'Level jam: (MD only, 1 jam for the whole level): ','type':'text','id':'lvMDJam'},
                    {'name':"MinNextWaveHealthPercentage",'displayTxt':'Minimum next wave health %: ','type':'number','min':'0','id':'minNextWavePercent', 'max':''},
                    {'name':'MaxNextWaveHealthPercentage','displayTxt':'Maximum next wave health %', 'type':'number','id':'maxWavePercent','min':'0','max':''},
                    {'name':"ZombieCountdownFirstWaveSecs",'displayTxt':'Zombie countdown first wave seconds: ', 'type':'number','min':'0','max':'','id':'zCDFirstWaveSecs'},
                    {'name':'ZombieCountdownFirstWaveConveyorSecs','displayTxt':'Zombie countdown first wave conveyor seconds: ','type':'number','min':'0','max':'9','id':'zCDFirstWaveConvoSecs'},
                    {'name':"ZombieCountdownHugeWaveDelay",'displayTxt':'Zombie countdown huge wave delay: ','type':'number','min':'0', 'max':'', 'id':'zCDHugeWaveDelay'}
                    ]
                }
                nest('Additional flag wave: ',undefined,'number',undefined,'additionalFW',undefined,false,true,undefined,undefined,undefined,undefined,undefined,addFlagWave);
                var aliasesWaveProp = ['WaveProperties'], wavePropsData = {}
                completeObjdata = function () {
                    wavePropsData.aliases = aliasesWaveProp;
                    wavePropsData.objclass = "WaveManagerProperties";
                    wavePropsData.objdata = userInput;
                    wavePropsData.objdata.AdditionalFlagWaves = addFlagWave;
                }
            }
            myGroupBox.appendChild(createButton(waveButtons[1], handler)); addText('      '); 
            handler = function () {
                clearInputArea(true);
                clearSubInputArea(true);
                alert('Don\'t know what is Escalation. :(');
            }
            myGroupBox.appendChild(createButton(waveButtons[2], handler, waveButtons[2]));

            //event button, probably I'll be able to fire an event for nest here to clear a global array for convenient, too many arrays currently
            function createEventButton() {
                newLine(); newLine(); showSubBox();
                waveEvent.forEach(function (a) {
                    addText(' ');
                    mySubGroupBox.appendChild(createButton(a, clickHandler, a, 'evButton'))
                });
            }

            //switch of events
            var clickHandler = function () {
                switch (this.id) {
                    case "Jam":
                        let arr = ['Rap', 'Punk', '8Bit', 'Metal', 'Ballad']; //unfinished
                        clearSubInputArea();
                        newSubLine();
                        addSubText('Music?');
                        newSubLine();
                        arr.forEach(function (songName) {
                            mySubGroupBox.appendChild(createButton(songName, handleSong, songName));
                        });
                        function handleSong() {
                        }
                        break;
                    case "LowTide":
                        myGrid = {
                            'data': [
                                { 'name': 'ColumnEnd', 'id': 'colEndTide', 'displayTxt': 'Column end: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'ColumnStart', 'id': 'colStartTide', 'displayTxt': 'Column start: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'TimeBeforeFullSpawn', 'id': 'timebFullSpawnTide', 'displayTxt': 'Time before full spawn: ', 'type': 'number', 'min': '0', 'max': '' },
                                { 'name': 'TimeBetweenGroup', 'id': 'timebweenGrTide', 'displayTxt': 'Time between group: ', 'type': 'number', 'min': '0', 'max': '' },
                                { 'name': 'WaveStartMessage', 'id': 'waveMessage', 'displayTxt': 'Wave start message: ', 'type': 'text' },
                                { 'name': 'ZombieCount', 'id': 'zCountTide', 'displayTxt': 'Zombie count: ', 'type': 'number', 'min': '0', 'max': '' },
                                { 'name': 'ZombieType', 'id': 'zTypeTide', 'displayTxt': 'Zombie ambush type: ', 'type': 'text' }
                            ]
                        }
                        runCreateObj.toSubmit = false;
                        createSubUI();
                        addSubEvButton();
                        completeObjdata = function () {
                            var lowAlias = ['Wave' + i + 'LowTideEvent'], lowObj = {};
                            lowObj.aliases = lowAlias;
                            lowObj.objclass = "BeachStageEventZombieSpawnerProps";
                            lowObj.objdata = userInput;
                            console.log(JSON.stringify(lowObj));
                        }
                        break;
                    case "GroundSpawn":
                        myGrid = {
                            'data': [
                                { 'name': 'ColumStart', 'id': 'GSColStart', 'displayTxt': 'Column start: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'ColumnEnd', 'id': 'GSColEnd', 'displayTxt': 'Coulumn end: ', 'type': 'number', 'min': '0', 'max': '9' }
                            ]
                        }
                        runCreateObj.toSubmit = false;
                        createSubUI();
                        askSubZ();
                        addSubEvButton();
                        completeObjdata = function () {
                            var groundAlias = ['Wave' + i + 'GroundSpawnEvent'], groundObj = {}, groundData = {}
                            groundObj.aliases = groundAlias;
                            groundObj.objclass = "SpawnZombiesFromGroundSpawnerProps";
                            groundData.Zombies = zArr;
                            groundObj.objdata = userInput;
                            groundObj.objdata.Zombies = zArr;
                            console.log(JSON.stringify(groundObj));
                        }
                        break;
                    case "(Sand/Snow)storm":
                        myGrid = {
                            'data': [
                                { 'name': 'ColumnEnd', 'id': 'colEndStorm', 'displayTxt': 'Column end: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'ColumnStart', 'id': 'colStartStorm', 'displayTxt': 'Column start: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'TimeBetweenGroup', 'id': 'timebweenGrStorm', 'displayTxt': 'Time between group: ', 'type': 'number', 'min': '0', 'max': '' },
                                { 'name': 'Waves', 'id': 'stormWaves', 'displayTxt': 'Waves: ', 'type': 'text' },
                                { 'name': 'Type', 'id': 'stormType', 'displayTxt': 'Storm type: (sandstorm, snowstorm) ', 'type': 'text' },
                            ]
                        }
                        createSubUI();
                        askSubZ();
                        addSubEvButton();
                        completeObjdata = function () {
                            var stormAlias = ['Wave' + i + 'StormEvent'], stormObj = {};
                            stormObj.aliases = stormAlias;
                            stormObj.objclass = "StormZombieSpawnerProps";
                            stormObj.objdata = userInput;
                            stormObj.objdata.Zombies = zArr;
                        }
                        break;
                    case "RaidingParty":
                        myGrid = {
                            'data': [
                                { 'name': 'SwashbucklerCount', 'id': 'bucklerCount', 'displayTxt': 'Swashbuckler count: ', 'type': 'number', 'min': '0', 'max': '' },
                                { 'name': 'GroupSize', 'id': 'raidGrSize', 'displayTxt': 'Group size: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'TimeBetweenGroup', 'id': 'timebweenGrTide', 'displayTxt': 'Time between group: ', 'type': 'number', 'min': '0', 'max': '' }
                            ]
                        }
                        createSubUI();
                        addSubEvButton();
                        completeObjdata = function () {
                            var raidAlias = ['Wave' + i + 'RaidingEvent'], raidObj = {};
                            raidObj.aliases = raidAlias;
                            raidObj.objclass = 'RaidingPartyZombieSpawnerProps';
                            raidObj.objdata = userInput;
                        }
                    case 'BotSwarm':
                        myGrid = {
                            'data': [
                                { 'name': 'ColumnEnd', 'id': 'colEndSwarm', 'displayTxt': 'Column end: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'ColumnStart', 'id': 'colStartSwarm', 'displayTxt': 'Column start: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'TimeBetweenGroup', 'id': 'timebweenGrSwarm', 'displayTxt': 'Time between group: ', 'type': 'number', 'min': '0', 'max': '' },
                                { 'name': 'TimeBeforeFullSpawn', 'id': 'timefullSpawnSwarm', 'displayTxt': 'Time before full spawn', 'type': 'number', 'min': '0', 'max': '' },
                                { 'name': 'GroupSize', 'id': 'raidGrSize', 'displayTxt': 'Group size: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'SpiderCount', 'id': 'spiderCount', 'displayTxt': 'Ambush count: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'SpiderZombieName', 'id': 'spiderName', 'displayTxt': 'Ambush name: ', 'type': 'text' },
                                { 'name': 'WaveStartMessage', 'id': 'waveMessSwarm', 'displayTxt': 'Wave message: ', 'type': 'text' },
                                { 'name': 'ZombieFallTime', 'id': 'zFallTimeSwarm', 'displayTxt': 'Zombie fall time: ', 'type': 'number', 'min': '0', 'max': '9' }
                            ]
                        }
                        createSubUI();
                        addSubEvButton();
                        completeObjdata = function () {
                            var swarmAlias = ['Wave' + i + 'SwarmEvent'], swarmObj = {};
                            swarmObj.aliases = swarmAlias;
                            swarmObj.objclass = "SpiderRainZombieSpawnerProps";
                            swarmObj.objdata = userInput;
                        }
                        break;
                    case 'TideChange':
                        myGrid = {
                            'data': [
                                { 'name': 'ChangeAmount', 'id': 'changeAmount', 'type': 'number', 'min': '0', 'max': '', 'displayTxt': 'Change amount' },
                                { 'name': 'ChangeType', 'id': 'changeType', 'type': 'text', 'displayTxt': 'Change type: ' },
                            ]
                        }
                        createSubUI();
                        addSubEvButton();
                        completeObjdata = function () {
                            var tideChangeAlias = ['Wave' + i + 'TideChangeEvent'], tideChangeObj = {};
                            tideChangeObj.aliases = tideChangeAlias;
                            tideChangeObj.objclass = "TidalChangeWaveActionProps";
                            tideChangeObj.objdata.TidalChange = userInput;
                        }
                        break;
                    case 'GridSpawn':
                        newSubLine();
                        myGrid = {
                            'data': [
                                { 'name': 'SpawnEffectAnimID', 'displayTxt': 'Spawn effect: ', 'id': 'spawnEffGS', 'type': 'text' },
                                { 'name': 'SpawnSoundID', 'displayTxt': 'Spawn sound: ', 'id': 'spawnSoundGS', 'type': 'text' }
                            ]
                        }
                        createSubUI();

                        nest('Type:', 'Count:', 'text', 'number', 'gridSpawnType', 'gridSpawnCount', true, false, true, 'Type', 'Count', manageGrid, undefined, nestArr1);
                        newSubLine();

                        nest('mX:', 'mY', 'number', 'number', 'mX', 'mY', true, true, true, 'mX', 'mY', undefined, undefined, nestArr2);
                        addSubEvButton();

                        var gridSAlias = ['Wave' + i + "GridSpawnEvent"], gridSObj = {};
                        completeObjdata = function () {
                            gridSObj.aliases = gridSAlias;
                            gridSObj.objclass = 'SpawnZombiesFromGridItemSpawnerProps';
                            gridSObj.objdata = userInput;
                            gridSObj.objdata.GraveStonePool = nestArr1;
                            gridSObj.objdata.SpawnPostionPool = nestArr2;
                            console.log(JSON.stringify(gridSObj))
                        }
                        break;
                    case 'SunDropper':
                        myGrid = {
                            'data': [
                                { 'name': 'SunAmountToDrop', 'displayTxt': 'Sun amount to drop: ', 'id': 'sunDropper', 'type': 'number', 'min': '0', 'max': '' }
                            ]
                        }
                        createSubUI();
                        addSubEvButton();
                        var dropperAlias = ['Wave' + i + 'SunDropperEvent'], dropperObj = {};
                        completeObjdata = function () {
                            dropperObj.aliases = dropperAlias;
                            dropperObj.objclass = "SunDropperWaveActionProps";
                            dropperObj.objdata = userInput;
                        }
                        break;
                    case 'SpawnFromGrid':
                        myGrid = {
                            'data': [
                                { 'name': 'AdditionalPlantfood', 'displayTxt': 'Wave plantfood amount: ', 'id': 'addPFSpawnFromGrid', 'type': 'number', 'min': '0', 'max': '' }
                            ]
                        }
                        createSubUI();

                        nest('Grid type to spawn from: ', undefined, 'text', undefined, 'gridSpawnType', undefined, false, false, undefined, undefined,
                            undefined, manageGrid, undefined, spawnGridNestArr)
                        newSubLine();

                        nest('Zombie type:', undefined, 'text', undefined, 'zTypeSpawnGrid', undefined, true, false, undefined,
                            'Type', undefined, validateZombie, undefined, zGridNestArr)

                        newSubLine(); addSubEvButton();
                        var spawnGridAlias = ['Wave' + i + 'SpawnFromGridEvent'], spawnGridObj = {};
                        completeObjdata = function () {
                            spawnGridObj.aliases = spawnGridAlias;
                            spawnGridObj.objclass = "SpawnZombiesFromGridItemSpawnerProps";
                            spawnGridObj.objdata = userInput;
                            spawnGridObj.objdata.GridTypes = spawnGridNestArr;
                            spawnGridObj.objdata.Zombies = zGridNestArr;
                            console.log(JSON.stringify(spawnGridObj))
                        };
                        break;
                        case 'Dino':
                        myGrid = {
                            'data': [
                                {'name':'DinoRow','id':'dinoRow','type':'number','displayTxt':'Dino row: ','min':'0','max':'4'},
                                {'name':'DinoType','id':'dinoType','type':'text','displayTxt':'Dino type: ',},
                                {'name':'DinoWaveDuration','id':'dinoDuration','type':'number','min':'0','max':'','displayTxt':'Duration: '}
                            ]
                        }
                        createSubUI();
                        addSubEvButton();
                        var dinoObj = {}, dinoAliases = ['Wave'+i+'DinoEvent'];
                        completeObjdata = function () {
                            dinoObj.aliases = dinoAliases;
                            dinoObj.objclass = "DinoWaveActionProps";
                            dinoObj.objdata = userInput;
                        }
                        break;
                        case 'FrostWind':
                        myGrid = {'data':[]}
                        createSubUI();
                        nest('Direction:', 'Row:','text','number','windDirection','windRow',true,false,true,'Direction','Row',
                        undefined,undefined,frostWindArr)
                        addSubEvButton();
                        var windObj = {}, windAliases = ['Wave'+i+'FrostWindEvent'];
                        completeObjdata = function () {
                            windObj.aliases = windAliases;
                            windObj.objclass = "FrostWindWaveActionProps";
                            windObj.objdata = {Winds: frostWindArr};
                            console.log(JSON.stringify(windObj));
                        }
                        break;
                        case 'ParachuteRain':
                        myGrid = {
                            'data': [
                                { 'name': 'ColumnEnd', 'id': 'colEndSwarm', 'displayTxt': 'Column end: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'ColumnStart', 'id': 'colStartSwarm', 'displayTxt': 'Column start: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'TimeBetweenGroup', 'id': 'timebweenGrSwarm', 'displayTxt': 'Time between group: ', 'type': 'number', 'min': '0', 'max': '' },
                                { 'name': 'TimeBeforeFullSpawn', 'id': 'timefullSpawnSwarm', 'displayTxt': 'Time before full spawn', 'type': 'number', 'min': '0', 'max': '' },
                                { 'name': 'GroupSize', 'id': 'raidGrSize', 'displayTxt': 'Group size: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'SpiderCount', 'id': 'spiderCount', 'displayTxt': 'Ambush count: ', 'type': 'number', 'min': '0', 'max': '9' },
                                { 'name': 'SpiderZombieName', 'id': 'spiderName', 'displayTxt': 'Ambush name: ', 'type': 'text' },
                                { 'name': 'WaveStartMessage', 'id': 'waveMessSwarm', 'displayTxt': 'Wave message: ', 'type': 'text' },
                                { 'name': 'ZombieFallTime', 'id': 'zFallTimeSwarm', 'displayTxt': 'Zombie fall time: ', 'type': 'number', 'min': '0', 'max': '9' }
                            ]
                        }
                        createSubUI();
                        addSubEvButton();
                        completeObjdata = function () {
                            var rainAlias = ['Wave' + i + 'RainEvent'], rainObj = {};
                            rainObj.aliases = swarmAlias;
                            rainObj.objclass = "ParachuteRainZombieSpawnerProps";
                            rainObj.objdata = userInput;
                        }
                        break;
                }
            };
        }

        function myReadData() {
            var a = {};
            myGrid.data.forEach(function insertObject(aliasesObject) {
                var val = document.getElementById(aliasesObject.id).value;
                if (val != "") {
                    if (aliasesObject.type === "number") { val = parseInt(val); }
                    a[aliasesObject.name] = val;
                    if (aliasesObject.type === 'checkbox') {
                       let chk =  document.getElementById(aliasesObject.id);
                        if (chk.checked == true) {a[aliasesObject.name] = true;}
                        else {a[aliasesObject.name] = false;}
                    }
                }
            }

            );
            return a;
        }

        function readRailsData() {
            var a = {};
            a['RailCartType'] = readTxtInput("railCartTypeID");
            a['Rails'] = rails;
            a['RailCarts'] = railCarts;
            return a;
        }


        //utilities
        //--------------------------------------------------------------------------------
        function clearInputArea(preserveButtons = false) {
            while (myGroupBox.firstChild) {
                if (myGroupBox.lastChild) {
                    var x = myGroupBox.lastChild.id;
                    if (x == 'Escalation' && preserveButtons) { newSubLine(); break; }
                }
                myGroupBox.removeChild(myGroupBox.lastChild);
            }
            myGroupBox.appendChild(document.createElement('br'))
        }

        function clearSubInputArea(preserveButtons = true) {
            while (mySubGroupBox.firstChild) {
                var x = mySubGroupBox.lastChild.id;
                if (x == 'SunDropper' && preserveButtons) { newSubLine(); break; }
                mySubGroupBox.removeChild(mySubGroupBox.lastChild);
            }
            mySubGroupBox.appendChild(document.createElement('br'))
        }

        //clears previous and create new input ui
        function createUI(c = null) {
            if (c == null) {
                clearInputArea();
            }
            var clsName = myGrid.className;
            //lay input boxes
            myGrid.data.forEach(function insertObject(aliasesObject) {
                //var x = document.createTextNode('For ' + clsName + ', ');
                //myGroupBox.appendChild(x);

                var x = document.createTextNode(aliasesObject.displayTxt);
                myGroupBox.appendChild(x);
                var bth = document.createElement('input');
                bth.type = 'text';
                bth.id = aliasesObject.id;
                bth.className = 'myClass';
                bth.type = aliasesObject.type;
                if (aliasesObject.type === "number") {
                    bth.min = aliasesObject.min;
                    bth.max = aliasesObject.max;
                }
                myGroupBox.appendChild(bth);
                myGroupBox.appendChild(document.createElement('br'))
            }
            );


            var clickHandler = function () {
                userInput = myReadData();
                completeObjdata();
                myGrid.data.forEach(function insertObject(aliasesObject) {
                    document.getElementById(aliasesObject.id).value = "";
                })
            }
            if (runCreateObj.toSubmit === true) {
                myGroupBox.appendChild(createButton('Submit', clickHandler));
            }

            if (c == null) {
                clickHandler = function () {
                    userInput = myReadData();
                    completeObjdata();
                    if (runCreateObj.run == true) {
                        completeObjdata.createObj();
                    }
                };
                myGroupBox.appendChild(createButton('Submit and generate chosen object', clickHandler));
            }
        }
        function createSubUI() {
            clearSubInputArea();

            var clsName = myGrid.className;
            //lay input boxes
            myGrid.data.forEach(function insertObject(aliasesObject) {
                var x = document.createTextNode(aliasesObject.displayTxt);
                mySubGroupBox.appendChild(x);
                var bth = document.createElement('input');
                bth.type = 'text';
                bth.id = aliasesObject.id;
                bth.className = 'myClass';
                bth.type = aliasesObject.type;
                if (aliasesObject.type === "number") {
                    bth.min = aliasesObject.min;
                    bth.max = aliasesObject.max;
                }
                mySubGroupBox.appendChild(bth);
                mySubGroupBox.appendChild(document.createElement('br'))
            }
            );

            var clickHandler = function () {
                userInput = myReadData();
                completeObjdata();
                myGrid.data.forEach(function insertObject(aliasesObject) {
                    document.getElementById(aliasesObject.id).value = "";
                })
            }
            if (runCreateObj.toSubmit === true) {
                mySubGroupBox.appendChild(createButton('Submit', clickHandler));
            }

        }



        //creates button object with name and click handler
        function createButton(name, clickHandler, id = '', className = '') {
            var button = document.createElement('button');
            button.innerHTML = name;
            button.onclick = clickHandler;
            button.type = "button";
            button.id = id;
            button.className = className;
            return button;
        }

        function createInput(type, id, className = 'myClass', value = '') {
            var inpt = document.createElement('input');
            inpt.type = type;
            inpt.id = id;
            inpt.className = className;
            inpt.value = value;
            myGroupBox.appendChild(inpt);
            return inpt;
        }


        function newLine() {
            myGroupBox.appendChild(document.createElement('br'));
        }
        function newSubLine() {
            mySubGroupBox.appendChild(document.createElement('br'));
        }

        function addText(txtt) {
            myGroupBox.appendChild(document.createTextNode(txtt));
        }

        function addSubText(txtt) {
            mySubGroupBox.appendChild(document.createTextNode(txtt));
        }

        function readIntInput(myId) {
            var val = document.getElementById(myId).value;
            if (val != "") {
                return parseInt(val);
            }
        }

        function readTxtInput(myId) {
            var val = document.getElementById(myId).value;
            if (val != "") {
                return val;
            }
        }

        function readBoolInput(myId) {
            var val = document.getElementById(myId).value;
            if (val.checked) {
                val = true;
                return val;
            }
        }

        function validateWave(a) {
            var val = "RTID(" + a + "@CurrentLevel)";
            return val;
        }

        function validateZombie(a) {
            var val = "RTID(" + a + "@ZombieType)";
            return val;
        }

        function manageGrid(a) {
            var val = "RTID(" + a + "@GridItemType)";
            return val;
        }

        function hideSubBox() {
            document.getElementById('mySubGroupBox').setAttribute('hidden', true);
        }

        function showSubBox() {
            document.getElementById('mySubGroupBox').removeAttribute('hidden');
        }
        function askZ() {
            var zArr = [];
            newLine(); addText('Zombie: '); myGroupBox.appendChild(createInput('text', 'zombie'));
            addText('  at row: '); myGroupBox.appendChild(createInput('text', 'rowW')); addText('  '); myGroupBox.appendChild(createButton('Add', handleZ));
            var handleZ = function () {
                var objW = {};
                var row = readIntInput('rowW');
                var zombieW = readTxtInput('zombie');
                objW.Type = validateWave(zombieW);
                if (row != null && row != undefined) { objW.Row = row };
                zArr.push(objW);
            }
        }

        function askSubZ() {
            newSubLine(); addSubText('Zombie: '); mySubGroupBox.appendChild(createInput('text', 'zombieSub'));

            var handleZ = function () {
                var objW = {};
                var row = readIntInput('rowWSub');
                var zombieW = readTxtInput('zombieSub');
                objW.Type = validateZombie(zombieW);
                if (row != null && row != undefined) { objW.Row = row };
                zArr.push(objW);
            };
            addSubText('  at row: '); mySubGroupBox.appendChild(createInput('text', 'rowWSub')); addSubText('  '); mySubGroupBox.appendChild(createButton('Add', handleZ));

        }

        function nest(firstText = '', secondText = '', firstType = '', secondType = '', firstId = '', secondId = '',
            toNest = Boolean, isFirstInt = Boolean, isSecondInt = Boolean,
            nestFirstProp = '', nestSecondProp = '', processFirstAns, processSecondAns, nestArr) {

            newSubLine(); addSubText(firstText + " "); mySubGroupBox.appendChild(createInput(firstType, firstId));
            //stop writing Spaghetti code :O

            var nester = function () {
                var obj = {};
                var firstAns, secondAns;

                if (isFirstInt == true) {
                    firstAns = readIntInput(firstId);
                } else {
                    firstAns = readTxtInput(firstId);
                }
                if (isSecondInt != undefined && isSecondInt != null && isSecondInt != Boolean) {
                    if (isSecondInt == true) {
                        secondAns = readIntInput(secondId)
                    } else {
                        secondAns = readTxtInput(secondId)
                    }
                } //check if 2nd input exists


                if (typeof processFirstAns == 'function') {
                    firstAns = processFirstAns(firstAns);
                }
                if (typeof processSecondAns == 'function' && secondType != undefined) {
                    secondAns = processSecondAns(secondAns);
                }

                if (toNest == true) {
                    if (firstAns != undefined) {
                        obj[nestFirstProp] = firstAns
                    }
                    if (secondAns != undefined && secondAns != null) {
                        obj[nestSecondProp] = secondAns
                    }
                    nestArr.push(obj);
                } else {
                    if (firstAns != undefined) {
                        nestArr.push(firstAns);
                    }
                }

            };
            if (secondType != null && secondType != undefined && secondType != '') { addSubText(' ' + secondText + ' '); mySubGroupBox.appendChild(createInput(secondType, secondId)); }
            mySubGroupBox.appendChild(createButton('Add', nester));
        }

        /* Usage:
        This is the form to create <text> <input> (.<text> <input>.) <add button> in a single line.
        (..) is optional.
        To use: Assign a variable to a function: `var a = nest();`
        Text = <text>
        Type = Input type
        Id = Input id
        
         */

        function addSubEvButton(a) {
            newSubLine();
            clickHandler = function () {
                userInput = myReadData();
                completeObjdata();
                if (runCreateObj.run == true) {
                    completeObjdata.createObj();
                }
                zArr = [];
            };
            mySubGroupBox.appendChild(createButton('Add event', clickHandler, 'evSubButton'));
        }
    </script>
</body>

</html>